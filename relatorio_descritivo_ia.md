Relatório de Arquitetura de Software: Modernização e Escalabilidade de Sistemas de ETL para Documentos Fiscais DesestruturadosSumário ExecutivoA engenharia de dados, no contexto fiscal brasileiro, enfrenta um desafio de heterogeneidade sem precedentes. A tarefa de processar Notas Fiscais de Serviço Eletrônicas (NFS-e) não se resume a um problema de ingestão de dados convencional, mas configura-se como um problema de "Domínio Caótico", onde a variabilidade é a única constante. O presente relatório técnico detalha a transição arquitetural de um script de extração linear para um framework orientado a objetos robusto, escalável e auditável. A análise foca na aplicação rigorosa de Padrões de Projeto (Design Patterns) clássicos e modernos, adaptados à linguagem Python, para resolver as dores centrais de variação de formato, instabilidade de leitura (OCR vs. Texto) e validação de regras de negócio complexas. O objetivo final é fornecer um blueprint arquitetural que permita a inclusão de centenas de layouts municipais com impacto marginal zero na estabilidade do núcleo do sistema.1. Introdução e Contextualização do Problema1.1 O Cenário da NFS-e e a Falta de PadronizaçãoDiferentemente da Nota Fiscal Eletrônica de mercadorias (NF-e, modelo 55), que possui um esquema XML nacionalmente unificado e rígido, a Nota Fiscal de Serviços (NFS-e) é de competência municipal. No Brasil, com mais de 5.570 municípios, isso resulta em uma fragmentação tecnológica massiva. Cada prefeitura tem autonomia para contratar seu próprio provedor de solução (ex: Ginfes, Betha, ISSNet, sistemas próprios), o que gera milhares de layouts visuais distintos e formatos de exportação inconsistentes.Para um sistema de ETL (Extract, Transform, Load) que visa ser "Universal", essa realidade impõe barreiras significativas. A "Dor" identificada no projeto atual — a variação de formato e o ruído de dados — não é uma anomalia, mas a natureza intrínseca do domínio. A solução atual, baseada em um pipeline linear com condicionais aninhados (if/else) e loops de tentativas, atinge um limite de complexidade ciclomática rapidamente. À medida que novas cidades são adicionadas, o custo de manutenção cresce exponencialmente, e a estabilidade do sistema decai.1.2 Limitações da Arquitetura Linear AtualA arquitetura vigente, descrita como um script procedural que tenta ler texto e falha para OCR, sofre de acoplamento rígido (Tight Coupling). A lógica de como ler um arquivo (I/O e OCR) está entrelaçada com a lógica de o que extrair (Regras de Negócio e Regex).As principais vulnerabilidades identificadas são:Fragilidade no Fallback: A lógica de alternância entre pdfplumber e Tesseract é hardcoded. Adicionar uma terceira opção (ex: uma API de IA Vision) exigiria refatorar o fluxo principal.Dificuldade de Teste: Testar a lógica de extração de valores requer instanciar todo o pipeline de leitura de PDF, tornando os testes unitários lentos e dependentes de arquivos físicos.Violação do Princípio Aberto/Fechado (OCP): Para suportar uma nova prefeitura (ex: Marília), é necessário modificar o código fonte existente, introduzindo riscos de regressão para prefeituras já estáveis (ex: Salvador).1.3 Objetivos da Refatoração ArquiteturalA proposta deste relatório é decompor o problema monolítico em componentes ortogonais, utilizando Padrões de Projeto para gerenciar a complexidade. A reestruturação visa atingir:Desacoplamento Temporal e Funcional: Separar a leitura física do arquivo da interpretação lógica dos dados.Extensibilidade por Plugins: Permitir que novos layouts sejam adicionados apenas criando novos arquivos, sem alterar o núcleo do sistema (Kernel).Resiliência a Falhas: Implementar estratégias de fallback e validação que recuperem erros de forma graciosa.A seguir, analisaremos profundamente cada padrão de projeto selecionado, justificando sua escolha com base na literatura técnica e detalhando sua implementação no ecossistema Python.2. Padrão Strategy: Abstração e Resiliência na Ingestão de DocumentosA primeira fronteira do sistema é a conversão de um arquivo binário (PDF, Imagem) em texto processável. A solução atual utiliza uma lógica condicional simples: "Tente A, se der erro, tente B". Em uma arquitetura robusta, isso é modelado através do Strategy Pattern.2.1 Conceito e JustificativaO Padrão Strategy define uma família de algoritmos, encapsula cada um deles e os torna intercambiáveis.1 No contexto deste extrator, o "algoritmo" é o mecanismo de extração de texto bruto. A aplicação deste padrão permite que o sistema principal (o Contexto) desconheça se o texto foi obtido através de parsing de vetores PDF, OCR local ou uma API em nuvem. O contrato é simples: Entra Arquivo -> Sai Texto.A variabilidade dos arquivos de entrada (PDFs nativos vs. Scans) exige que o sistema possua múltiplas "ferramentas" na sua caixa, mas que a decisão de qual usar seja transparente para as etapas subsequentes de mineração de dados.2.2 Implementação da Interface de EstratégiaEm Python, a definição do contrato é feita através de Classes Base Abstratas (ABCs). Isso garante que todas as estratégias concretas implementem os métodos necessários, proporcionando segurança de tipos e previsibilidade.2Pythonfrom abc import ABC, abstractmethod
from typing import Optional

class TextExtractionStrategy(ABC):
    """
    Interface abstrata para estratégias de extração de texto.
    Garante que qualquer mecanismo de leitura (OCR, Nativo, Cloud)
    siga o mesmo contrato de interação.
    """
    
    @abstractmethod
    def extract(self, file_path: str, **kwargs) -> str:
        """
        Extrai o texto bruto de um arquivo especificado.
        
        Args:
            file_path: Caminho absoluto para o arquivo.
            **kwargs: Parâmetros opcionais de configuração (dpi, psm, etc).
            
        Returns:
            str: O texto extraído bruto.
            
        Raises:
            ExtractionError: Se houver falha irrecuperável no processo.
        """
        pass
2.3 Estratégias Concretas e Detalhes Técnicos2.3.1 NativeTextStrategy (Alta Performance)Esta estratégia é a preferencial. Ferramentas como pdfplumber ou PyPDF2 acessam a camada de conteúdo do PDF (stream de objetos) e extraem os caracteres diretamente.Vantagens: Velocidade extrema (milissegundos), precisão de 100% nos caracteres (pois não há interpretação visual), e retenção de metadados espaciais (layout).3Desafios: PDFs com "texto sujo" (mojibake) onde a codificação de fontes está corrompida. A estratégia deve incluir uma validação básica de integridade (ex: verificar se a densidade de caracteres alfanuméricos é aceitável) antes de retornar o sucesso.2.3.2 TesseractOCRStrategy (Alta Compatibilidade)Quando o arquivo é uma imagem (raster), o OCR é mandatório. Esta estratégia encapsula a complexidade do pytesseract e do motor Tesseract 4.0+ (baseado em LSTM - Redes Neurais Recorrentes).4Pipeline Interno: Esta classe não deve apenas chamar o Tesseract. Ela deve orquestrar um mini-pipeline de visão computacional:Rasterização: Converter PDF para imagem (usando pdf2image) em alta resolução (mínimo 300 DPI).Pré-processamento (OpenCV): Aplicar binarização (thresholding) para transformar tons de cinza em preto e branco puro, facilitando a detecção de bordas. Remover ruído "salt-and-pepper" que é comum em scans antigos.4Execução do OCR: Chamar o motor com parâmetros configurados (ex: --psm 6 para assumir um bloco de texto uniforme).Encapsulamento: Toda a sujeira de lidar com caminhos de executáveis e bibliotecas de imagem fica contida aqui, mantendo o código principal limpo.2.4 O Padrão Composite para Fallback RobustoPara resolver a "Tentativa A -> Tentativa B" sem if/else, utilizamos uma variação do padrão Composite ou Chain of Responsibility aplicada às estratégias. Criamos uma FallbackStrategy que contém uma lista de outras estratégias.6Esta estratégia composta itera sobre seus filhos. Se a NativeTextStrategy retornar vazio ou falhar, ela captura a exceção silenciosamente e passa para a TesseractOCRStrategy. Se todas falharem, ela levanta uma exceção agregada.CaracterísticaAbordagem Atual (Procedural)Abordagem Proposta (Strategy + Composite)Fluxo de Controleif native_success:... else: do_ocr()pipeline.extract(file) (Polimorfismo)ExtensibilidadeEdição de código fonte arriscadaAdição de nova classe na lista de configuraçãoTratamento de ErroDisperso e repetitivoCentralizado na classe CompositeTestabilidadeDifícil isolar o OCRMocking trivial da interface TextExtractionStrategy2.5 Insights de Segunda Ordem: O Custo do "Hybrid Fallback"A literatura sugere que a distinção entre "PDF Texto" e "PDF Imagem" nem sempre é binária.3 Existem PDFs híbridos (texto sobre imagem) ou PDFs onde o texto existe mas é "lixo" (encoding incorreto).Uma implementação avançada da FallbackStrategy não deve apenas checar se o texto é vazio. Ela deve implementar uma Heurística de Qualidade. Se a estratégia nativa retornar texto, mas este texto tiver 40% de caracteres não imprimíveis, a estratégia deve considerar isso uma "falha lógica" e acionar o OCR, mesmo que tecnicamente a extração tenha ocorrido. Esse nível de robustez é impossível de manter em scripts lineares simples.3. Chain of Responsibility: O Pipeline de Mineração e LimpezaUma vez que o texto bruto foi obtido, o desafio se desloca para a extração de dados estruturados (Mineração). A solução atual utiliza um loop sobre uma lista de Regex ("Priority List"). Embora funcional para casos simples, essa abordagem falha quando há dependências complexas ou necessidade de pré-processamento específico por campo.3.1 O Problema da Extração SequencialEm um loop simples, a lógica de "parada" (break) é binária: achou ou não achou. Não há espaço para lógica de "Refinamento". Além disso, o tratamento de "distratores" (ex: número do RPS confundido com número da Nota) exige condicionais complexas dentro do loop.8O padrão Chain of Responsibility (CoR) transforma esse processo. Em vez de um loop cego, temos uma corrente de objetos especialistas (Handlers), onde cada um tem a chance de processar a informação, refiná-la ou passá-la adiante.3.2 Estrutura do Handler de ExtraçãoCada "Elo" da corrente representa uma tentativa de extração com uma lógica específica.Pythonclass ExtractionHandler(ABC):
    def __init__(self, next_handler: Optional['ExtractionHandler'] = None):
        self._next_handler = next_handler

    def handle(self, context: ExtractionContext) -> Optional:
        """
        Tenta processar. Se tiver sucesso, retorna o resultado.
        Se não, delega para o próximo.
        """
        result = self._extract(context)
        if result and result.is_valid():
            return result
        
        if self._next_handler:
            return self._next_handler.handle(context)
        
        return None # Fim da linha

    @abstractmethod
    def _extract(self, context) -> Optional:
        pass
3.3 Tipologia de Handlers para NFS-ePara resolver o problema dos "distratores" e a variabilidade de layout, propomos uma cadeia estratificada de handlers para cada campo crítico (ex: Número da Nota) 8:AnchorBasedHandler (Alta Precisão): Este handler procura por âncoras textuais rígidas. Ex: "Número da Nota:" seguido imediatamente de dígitos. Se encontrado, a confiança é alta e a cadeia para.SpatialHandler (Contextual): Se a extração nativa (pdfplumber) for usada, temos as coordenadas X/Y. Este handler pode buscar o número que está no canto superior direito (posição padrão em muitos layouts), ignorando o texto ao redor. Isso resolve a confusão com o RPS, que geralmente está em outra posição.PatternFallbackHandler (Baixa Precisão): Usa uma regex genérica (ex: \d{8,}) para encontrar qualquer sequência numérica plausível. Este é o último recurso.3.4 Higienização Integrada (The Decorator Touch)O usuário mencionou uma etapa de "Limpeza Cirúrgica" (remover a palavra "RPS"). No padrão CoR, a limpeza pode ser um passo preliminar na cadeia ou implementada via Decorator Pattern nos handlers.Um SanitizingHandler pode ser colocado no início da cadeia. Ele não extrai nada; ele apenas recebe o texto, aplica regex de limpeza (remove "RPS 1234"), modifica o contexto e passa para o próximo handler. Isso garante que os handlers de extração subsequentes operem sobre dados limpos, sem que eles precisem saber sobre a lógica de limpeza.103.5 Tabela: Loop de Regex vs. Chain of ResponsibilityCritérioLoop de Regex (Atual)Chain of Responsibility (Proposto)Complexidade LógicaAlta (Regex complexas tentam fazer tudo)Baixa (Cada handler faz uma coisa simples)ManutenibilidadeAdicionar regex nova requer cuidado com a ordemHandlers são plugáveis e reordenáveisContextoRegex não vê contexto (apenas string)Handlers podem acessar metadados (posição, página)DepuraçãoDifícil saber qual regex "pegou" erradoLogs indicam exatamente qual Handler processou4. Factory Pattern e Registry: Gerenciamento Escalável de MunicípiosO Brasil possui milhares de prefeituras. Criar uma classe para cada uma é inevitável, mas gerenciar a instanciação dessas classes é o gargalo. Um if/elif gigante verificando o nome do arquivo é insustentável. O Factory Pattern, potencializado por um Registry Dinâmico, é a solução definitiva para este problema de escala.124.1 O Problema da Descoberta (Discovery)Frequentemente, o nome do arquivo não é confiável (ex: "scan001.pdf"). O sistema precisa identificar o layout baseando-se no conteúdo do arquivo (Content-Based Dispatching).4.2 O Padrão Registry com Decoradores em PythonEm vez de modificar a ExtractorFactory a cada nova prefeitura, utilizamos a metaprogramação do Python. Criamos um decorador @register_extractor que, ao ser lido pelo interpretador, inscreve a classe em um dicionário central.13Python# registry.py
EXTRACTOR_REGISTRY =

def register_extractor(cls):
    """Decorador para auto-registrar extratores."""
    EXTRACTOR_REGISTRY.append(cls)
    return cls

# extractors/sp_sao_paulo.py
@register_extractor
class SaoPauloExtractor(BaseExtractor):
    @staticmethod
    def can_handle(text: str) -> bool:
        return "PREFEITURA DO MUNICÍPIO DE SÃO PAULO" in text.upper()
4.3 A Factory InteligenteA InvoiceExtractorFactory não possui hardcode. Seu método get_extractor(text) itera sobre o EXTRACTOR_REGISTRY, chamando o método estático can_handle() de cada classe registrada. O primeiro que responder True é instanciado e retornado.Isso permite uma arquitetura de Plugins. Novos arquivos de extratores podem ser soltos em uma pasta plugins/. Um script de inicialização varre essa pasta e importa os módulos. O registro acontece automaticamente. O núcleo do sistema permanece intocado, respeitando estritamente o princípio OCP (Open/Closed).154.4 Resolvendo Conflitos de LayoutE se dois layouts forem parecidos? A Factory pode implementar um sistema de pontuação (Scoring). O método can_handle retorna um float (confiança) em vez de booleano. A Factory pergunta a todos os extratores e instancia aquele com maior pontuação. Isso é crucial para prefeituras que usam sistemas white-label (ex: Provedor Ginfes), onde o layout é idêntico para cidades diferentes, mudando apenas o brasão e o nome da cidade.5. Template Method: A Orquestração do Processo InvarianteEnquanto Strategy, CoR e Factory lidam com as partes móveis, o Template Method define a estrutura fixa do processo. Todo processamento de NFS-e, independente da cidade, segue o mesmo ciclo de vida macro: Ler -> Limpar -> Extrair -> Validar -> Persistir.165.1 A Classe Base AbstractInvoiceProcessorEsta classe define o esqueleto do algoritmo no método process().Pythonclass AbstractInvoiceProcessor(ABC):
    def process(self, file_path: str):
        # Passo 1: Leitura (Strategy)
        raw_text = self.read_file(file_path)
        
        # Passo 2: Limpeza (Hook)
        clean_text = self.sanitize(raw_text)
        
        # Passo 3: Extração (Abstract/Factory)
        data_model = self.extract_data(clean_text)
        
        # Passo 4: Validação (Specification)
        if self.validate(data_model):
            self.save(data_model)
        else:
            self.handle_error(data_model)
5.2 Hooks vs. Métodos AbstratosMétodos Abstratos (extract_data): Obrigam as subclasses (ex: SalvadorProcessor) a implementar a lógica de extração específica (definindo a Chain of Responsibility daquela cidade).Hooks (sanitize): Métodos com implementação padrão vazia ou genérica na classe base. Subclasses podem sobrescrevê-los se necessário.Exemplo: A prefeitura de Marília pode adicionar marcas d'água no PDF. A classe MariliaProcessor sobrescreve sanitize para remover essas marcas antes da extração. As outras classes usam o padrão.Isso elimina a duplicação de código (DRY) para tarefas comuns (como logging, tratamento de exceção de I/O, conexão com banco de dados) enquanto permite flexibilidade total nos pontos de variação.176. Specification Pattern: Validação de Dados e Regras de NegócioA validação de dados fiscais é complexa e frequentemente condicional. "O valor do ISS só é obrigatório se a alíquota for maior que zero, a menos que seja isento". Codificar isso em if aninhados dentro do método de extração cria código espaguete.6.1 Desacoplando Regras com SpecificationsO Specification Pattern encapsula uma regra de negócio em uma classe única, testável e reutilizável.18Pythonclass BusinessRule(ABC):
    @abstractmethod
    def is_satisfied_by(self, invoice) -> bool:
        pass

class IssValidRule(BusinessRule):
    def is_satisfied_by(self, invoice) -> bool:
        if invoice.aliquota > 0:
            return invoice.valor_iss > 0
        return True
6.2 Composição Booleana de RegrasA grande vantagem é a capacidade de compor regras complexas a partir de regras simples:RegraFinal = RegraDataValida() AND (RegraCNPJ() OR RegraCPF()).Isso permite que as regras de validação sejam definidas declarativamente, talvez até lidas de um arquivo de configuração JSON para cada prefeitura, aumentando a flexibilidade do sistema sem recompilação.7. Robustez, Escalabilidade e Idiomas PythonicosAlém dos padrões estruturais, a robustez em escala exige atenção à gestão de recursos e concorrência.7.1 Concorrência e ParalelismoO processamento de OCR é intensivo em CPU (CPU-bound), enquanto a leitura de PDF é intensiva em I/O. Em Python, devido ao GIL (Global Interpreter Lock), threads não são eficazes para o OCR.A arquitetura deve utilizar o módulo multiprocessing ou bibliotecas como Celery/Dask. Como o pipeline desenhado (Strategy + Template) é Stateless (o processamento de uma nota não depende da anterior), o paralelismo é trivial ("Embarrassingly Parallel"). Cada arquivo pode ser despachado para um worker isolado.207.2 Gestão de Memória com GeradoresAo processar milhares de PDFs, carregar todos em memória é fatal. O pipeline deve operar com Generators (yield). O método de leitura da pasta deve ser um gerador que entrega um caminho de arquivo por vez. O Template Method processa e descarta os dados pesados (imagens rasterizadas do OCR) imediatamente após o uso, invocando o Garbage Collector se necessário.217.3 Data Quality e PydanticPara garantir a estrutura dos dados de saída, recomenda-se o uso de Pydantic. Ele funciona como uma camada de validação de esquema (Schema Validation) mais robusta que dicionários puros.O método extract_data deve retornar uma instância de InvoiceModel (Pydantic). Isso garante que, se um campo obrigatório estiver faltando ou se uma string for passada onde se espera um float, o sistema falhará cedo e explicitamente (Fail Fast), com mensagens de erro detalhadas, antes de tentar gravar no banco de dados.158. Estudo de Caso Simulado: Implementando "Marília" vs "Salvador"Para concretizar a teoria, visualizemos a implementação de dois casos distintos sob a nova arquitetura.Caso A: Salvador (Layout Padrão, PDF Texto)Factory: Detecta "Salvador" no cabeçalho. Instancia SalvadorProcessor.Strategy: FallbackStrategy tenta NativeText. Sucesso rápido.Template: Chama sanitize (padrão). Chama extract.CoR: SalvadorHandlers são simples, baseados em Regex posicionais, pois o layout é limpo.Resultado: Processamento em < 0.5s.Caso B: Marília (Layout Antigo, Scan ruidoso, Distratores)Factory: Detecta padrão visual ou palavras-chave de Marília. Instancia MariliaProcessor.Strategy: FallbackStrategy tenta NativeText. Falha (ou retorna lixo). Aciona TesseractOCRStrategy.Interno: Binariza imagem, remove bordas escuras. OCR roda.Template: Chama sanitize. A implementação de Marília inclui um RemoveRPSDecorator porque sabe-se que o OCR confunde o cabeçalho do RPS com a nota.CoR: Usa FuzzyMatchingHandler (biblioteca fuzzywuzzy ou rapidfuzz) para encontrar campos, pois o OCR pode ter trocado "NOTA" por "N0TA".Validation: Specification verifica se o ISS retido bate com a lista de serviços da cidade.Resultado: Processamento em ~3.0s, dados consistentes e validados.9. Conclusão e Roteiro de ImplementaçãoA transição do script atual para esta arquitetura orientada a padrões não é apenas uma melhoria estética; é um imperativo de engenharia para viabilizar a escala.Strategy resolve a instabilidade de entrada.Chain of Responsibility resolve a complexidade de extração.Factory/Registry resolve a expansão geográfica.Template Method garante a governança do processo.Specification garante a integridade dos dados.Roadmap SugeridoFase 1 (Fundação): Implementar TextExtractionStrategy e o fallback. Isso estanca os erros de leitura imediata.Fase 2 (Estrutura): Criar AbstractInvoiceProcessor (Template Method) e migrar a lógica atual para dentro dele.Fase 3 (Expansão): Implementar o Registry e começar a separar as lógicas de Salvador e SP em arquivos distintos.Fase 4 (Refinamento): Substituir os loops de Regex por Chains of Responsibility progressivamente.Esta arquitetura transforma o "Extrator Universal" de uma ferramenta frágil em uma plataforma industrial, capaz de absorver o caos fiscal brasileiro e entregar dados estruturados com confiabilidade e auditabilidade.10. Referências Técnicas IntegradasA elaboração deste relatório baseou-se em práticas consolidadas de engenharia de software e documentação técnica de bibliotecas Python.Padrões GoF em Python:.1OCR e Processamento de Imagem:.3Pipeline de Dados e ETL:.17Validação e Qualidade de Dados:.18Python Idioms e Metaprogramação:.10